#!/bin/env perl
#=======================================================================#
#==PROLOGUE sample toolscript
#=======================================================================#


use XML::LibXML;
# sudo apt-get install zlib1g-dev libxml2-dev
# sudo cpan install XML::LibXML

#--- zef
# zef - create zefania bible xml file 
#     https://sourceforge.net/projects/zefania-sharp/files/Bibles/
#
#     developed,tested on UBUNTU, required tools:
#      wget nslookup
#
# DISCLAIMER: this tool can be used to extract bible-data from websites.
#     You must obey to the copyright and licensing rules that apply to that data.
#     This tool in no way gives any right for storing or using that data.
#
# Usage:
#   zef [common options] <zefcommand> [command options]
#
# zefcommand:
#   zef help
#   zef nbg               # extract from nbg website
#
# Common options:
#   -v|--verbose : verbose
#   -t|--trace : trace (verbose printing script-line number)
#   -bw|--bw : no colors
#   -a|--autoconfirm : selects default choices
#   -noggc|--noggc : no use of GGC (if set defaults to GUTSPL_NOGGC)
# -
#
# Example:
#    zef help
#---

# unimplemented (vs gutsh)
#   -env=<file> : file to source
#   -ggc=<ggc> : GGC selection to use

# use common functions
# TAG is *<toolname in GGC>*
my $TAG="*zef*";
my $nbghost="debijbel.nl";
my $nbgip;
my $nbgurl;
my @GETheader;
my @Template;

# bookTLA#maxchapter
my @books=qw(
GEN:Genesis:1
);

#=======================================================================#
#==gutspl=CHECKSUM=29149
#=======================================================================#
#==BEGIN gutspl injection part == do not alter
#=======================================================================#

BEGIN { $| = 1 }
use strict;
use Term::ANSIColor;
use Cwd 'realpath';
use Cwd;
use File::Basename;
use Sys::Hostname;
use JSON::PP;
use Data::Dumper;
use POSIX qw(strftime);
use Net::Domain qw(hostfqdn);

my $curlbaseurl="";
my $curlparm="";
my $curltarget="";

my $THISSCRIPT=realpath( $0 );
my $THISSCRIPTDIR=dirname( ${THISSCRIPT});
$ENV{PATH}.=":$THISSCRIPTDIR";

my $TOOLARGS=join( " ", @ARGV);
my $TMP=$ENV{TMP} || "/tmp";
my $C_NORM;
my $C_NOT;
my $C_VER;
my $C_DEB;
my $C_ERR;
my $C_WRN;
my $C_ASK;
my $C_TRC;
my $C_OK;
my $C_NOK;
my $C__UP;
my $C_DWN;
my $user=$ENV{USER} || $ENV{USERNAME} || "?user" ;
$user=lc($user);

my $COMMON_ARGS="";
my $opt_bw=0;
my $confirm_answer="";
my $opt_ac=0;
my $opt_noggc=0;
if ( defined $ENV{"GUTSPL_NOGGC"} ) {$opt_noggc=$ENV{"GUTSPL_NOGGC"}; }
my $opt_ggc="";
my $opt_guts_platform="";
my $opt_env;
if ( $ENV{GUTPL_NOGGC}) { $opt_noggc=$ENV{GUTPL_NOGGC}; }
my $ERRORTAG="$TAG ERROR:";
my $WARNINGTAG="$TAG WARNING:";
my $NOTICETAG="$TAG NOTICE:";
my $VERBOSETAG="$TAG VERBOSE:";
my $DEBUGTAG="$TAG";
my $ASKTAG="$TAG";

my $opt_debug=$ENV{GUTSPL_DEBUG} || 0;
my $opt_verbose=$ENV{GUTSPL_VERBOSE} || 0;
my $opt_trace=$ENV{GUTSPL_TRACE} || 0;
# returns 0 if common option processed - cannot shift
sub common_option($) {
    my $opt=shift;

    if ( "$opt" eq "-bw" || "$opt" eq "--bw" ){
      $COMMON_ARGS="$COMMON_ARGS -bw";
      $opt_bw=1;
      return 0;
    } elsif( "$opt" eq "-v" || "$opt" eq "--verbose" ) {
      $opt_verbose=$opt_verbose + 1;
      $COMMON_ARGS="$COMMON_ARGS -v";
      return 0;
    } elsif( "$opt" eq "-d" || "$opt" eq "--debug" ) {
      $opt_debug=$opt_debug + 1;
      $COMMON_ARGS="$COMMON_ARGS -d";
      return 0;
    } elsif( "$opt" eq "-t" || "$opt" eq "--trace" ) {
      $opt_verbose=$opt_verbose + 1;
      $opt_trace=$opt_trace + 1;
      $COMMON_ARGS="$COMMON_ARGS -t";
      return 0;
    } elsif( "$opt" eq "-a" || "$opt" eq "--autoconfirm" ) {
      $COMMON_ARGS="$COMMON_ARGS -a";
      $opt_ac=1;
      return 0;
    } elsif( "$opt" eq "-na" ) {
      $COMMON_ARGS="$COMMON_ARGS -na";
      $opt_ac=0;
      return 0;
    } elsif( "$opt" eq "-noggc" || "$opt" eq "--noggc" ) {
      $COMMON_ARGS="$COMMON_ARGS -noggc";
      $opt_noggc=1;
      return 0;
    } elsif( "$opt" =~ "-env=" ) {
      $COMMON_ARGS="$COMMON_ARGS $opt";
      $opt_env=$opt;
      $opt_env =~ s/^[^=]*=//;
      error( "oeps no sourcing" ) && exit 1; 
      #. $opt_env || exit 1
      return 0;
    } elsif( "$opt" =~ "-ggc=" )  {
      $COMMON_ARGS="$COMMON_ARGS $opt";
      $opt_ggc=$opt;
      $opt_ggc =~ s/^[^=]*=//;
      $ENV{GGC_WORLD}="$opt_ggc";
      return 0;
    } elsif( "$opt" =~ "-guts_platform=" )  {
      $opt_guts_platform=$opt;
      $opt_guts_platform=~ s/^[^=]*=//;
      $ENV{GUTS_PLATFORM}="$opt_guts_platform";
      return 0;
    } elsif( "$opt" eq "-?" )  {
      usage();
      exit 0;
    }
    return 1
}

sub common_init() {
  my ($bw) = @_;
  debug("init");

  if ( ! $ENV{TF_ORGANIZATION} ) {
    my $fq=hostfqdn(); my $org=$fq; $org=~ s/\.[^\.]*$//; $org=~ s/^.*\.//;  $ENV{TF_ORGANIZATION}=$org;
  }
  if ( ! $ENV{TF_DOMEXT} ) {
    my $fq=hostfqdn(); my $domext=$fq; $domext=~ s/^.*\.//;  $ENV{TF_DOMEXT}=$domext;
  }
  if ( ! $ENV{TF_GITPROJ} ) {
    $ENV{TF_GITPROJ}="gitproject";
  }

  $C_NORM=color("reset");
  $C_ASK=color("black on_green");

  $C_VER=color("bold white on_blue");
  $C_NOT=color("bold cyan on_blue");
  $C_DEB=color("bold white on_magenta");
  $C_ERR=color("bold white on_red");
  $C_WRN=color("bold white on_yellow");
  $C__UP=color("bold white on_magenta");
  $C_DWN=color("white on_white");
  $C_OK=color("bold white on_green");
  $C_NOK=color("bold white on_red");
  $C_TRC=color("bold red on_yellow");

  if ($bw) {
   $C_NORM='';
   $C_VER='';
   $C_NOT='';
   $C_DEB='';
   $C_ERR='';
   $C_WRN='';
   $C_ASK='';
   $C__UP='';
   $C_DWN='';
   $C_OK='';
   $C_NOK='';
   $C_TRC='';
  }
  $VERBOSETAG=$C_VER.$TAG.$C_NORM. " ";
  $NOTICETAG=$C_NOT.$TAG.$C_NORM. " ";
  $DEBUGTAG=$C_DEB.$TAG.$C_NORM. " ";
  $ERRORTAG=$C_ERR.$TAG.$C_NORM. " ERROR";
  $WARNINGTAG=$C_WRN.$TAG.$C_NORM. " WARNING";
  $ASKTAG=$C_ASK.$TAG.$C_NORM;

  if ( $opt_verbose ) {
    my $MYTAG="${C__UP}*${C_NORM}";
    my @NOW=localtime();
    my $date= strftime('%Y-%m-%dT%H:%M:%S', @NOW);

    my $line=center( "started at $date","$TAG","*");
    print( "${C__UP}$line${C_NORM}\n");
    $line="${C_TRC} C_TRC ${C_ERR} C_ERR ${C_WRN} C_WRN ${C_ASK} C_ASK ${C_DWN} C_DWN ${C__UP} C__UP ${C_VER} C_VER ${C_NOT} C_NOT ${C_OK} C_OK ${C_NOK} C_NOK ${C_NORM} C_NORM";
    print( "$MYTAG${C__UP}$line${C_NORM}\n");
    print( "$MYTAG  HOST=". hostname(). " PID=$$ PPID=". getppid()."\n");
    print( "$MYTAG  USER=$user\n" );
    #print( "$MYTAG  uname -a="$(uname -a)
    print( "$MYTAG  PATH=$ENV{PATH}\n");
    print( "$MYTAG  SCRIPT=". realpath($0)."\n");
    print( "$MYTAG  ARGS=${TOOLARGS}\n");
    print( "$MYTAG  \$^O=$^O\n");
    for my $k (qw (GUTS_PLATFORM GGC_HOME GGC_WORLD TMP TEMP)) {
      print( "$MYTAG  $k=$ENV{$k}\n");
    }
    $line=center("***");
    print( "${C__UP}$line${C_NORM}\n");
  }


  for my $e (qw( http_proxy HTTP_PROXY https_proxy HTTPS_PROXY)) {
    if ( $ENV{$e} ) {
      notice("$e=$ENV{$e}");
    }
  }
  if ( $opt_verbose ) {
    my $line=center("***");
    my $MYTAG="${C__UP}*${C_NORM}";
    print( "${C__UP}$line${C_NORM}\n");
    for my $k (qw (TF_ORGANIZATION TF_DOMEXT TF_GITPROJ )) {
      print( "$MYTAG  $k=$ENV{$k}\n");
    }
    print( "${C__UP}$line${C_NORM}\n");
  }

  if ( import_ggc() !=0 ) {return 1;}


  return 0;  
}

sub import_ggc() {
    if ( ! "$ENV{GGC_GITPROJ}" ) { $ENV{GGC_GITPROJ}=$ENV{TF_GITPROJ}; }
    if ( ! "$ENV{GGC_HOME}" && -d "$ENV{HOME}/GGC" ) { $ENV{GGC_HOME}="$ENV{HOME}/GGC"; }
    if ( ! "$ENV{GGC_HOME}" && -d "$ENV{HOME}/HOUSTON/$ENV{GGC_GITPROJ}-ggc-global" ) { $ENV{GGC_HOME}="$ENV{HOME}/HOUSTON/$ENV{GGC_GITPROJ}-ggc-global"; }

    if ( defined $ENV{GGC_HOME} && $ENV{GGC_HOME} ne "" ) {
      if ( -d "$ENV{GGC_HOME}" ) {
        $ENV{GGC_WORLD_SELECTED}=undef;
        my $GGCTOOL=$TAG;  $GGCTOOL=~s/\*//g;
        verbose("GGC import : $ENV{GGC_HOME}/ggc.sh show $GGCTOOL -perlvars");
        if ( "$GGCTOOL" ) { 
           my $ggcinfo=`$ENV{GGC_HOME}/ggc.sh show $GGCTOOL -perlvars`;
           my $rc=$?;
           if ( "$ggcinfo" =~ /tool .* is unknown/ ) {
             verbose("GGC import SKIPPED: $ggcinfo");
           } elsif ($rc != 0) {
             verbose("GGC import NOT OK: $ggcinfo");
             return 1;
           } else {
             verbose("GGC import OK");
             my @l=split( /\n/,$ggcinfo );
             $ggcinfo="";
             for my $l (@l) {
                verbose("GGC import: $l");
                if ($l =~ /^#/) { next; }
                if ($l =~ /^GGC[ :]/ ) { warn($l); next; }
                $ggcinfo.="$l\n";
             }
             eval "$ggcinfo";
             if ($@) {
                error( "GGC import failed: $@" );
                return 1
             }
           }
        }
      } else {
        warning("GGC_HOME='$ENV{GGC_HOME}' is not a directory");
      }
    } else {
        verbose("import_ggc: GGC_HOME is not set: skipped");
    }
    return 0
}


sub common_help {
 my $topic=shift;
 if ( $topic =~ /-*(all|ALL)/ ) {
        system("sed -n '/^#--- /,/^#---\$/p' ${THISSCRIPT}");
        return 0;
 }

 if ( ! $topic ) {
   usage();
   $topic="help";
 }
 system("sed -n '/^#---.*${topic}.*\$/,/^#---\$/p' ${THISSCRIPT} | grep -v \"^#---\"");
 return 0;
}

# read cache netrc info
my %netrc=();
my $netrc_done=0;
sub common_read_netrc() {
  if ( $netrc_done ==1 ) { return \%netrc; }

  my @ee=();
  if ( open NETRC, $ENV{HOME}."/.netrc") {
          @ee=<NETRC>;
          close NETRC;
  }
  my ($machine,$login,$pass);
  for my $e (@ee) {
            chomp $e;
            next if ($e =~/^[ #]/);
            next if ($e =~/^[ ]*$/);
            $machine=$e;
            $machine =~ s/.*machine\s+//;
            $machine =~ s/\s.*//;

            $pass=$e;
            $pass =~ s/.*password\s+//;
            $pass =~ s/\s.*//;

            $login=$e;
            $login =~ s/.*login\s+//;
            $login =~ s/\s.*//;


	    my %entry=();
	    $entry{machine}=$machine;
	    $entry{login}=$login;
	    $entry{password}=$pass;
            my $parm =$machine;
            $parm =~ s/.*=//;
	    $entry{parm}=$parm;
            my $mkey="$machine";
            $mkey =~ s/=.*//;
            next if ( ! $mkey );
            my $mlkey="$mkey-$login";
	    $netrc{$mlkey}=\%entry;
            # if ( ! $netrc{$mkey} ) {
            #  $netrc{$mkey}=\%entry;
            #}
  }
  return \%netrc;
}
# get netrc entry fuzzy matched (case insensitive, prefix (like simple host name)
sub common_get_netrc {
  my ($inkey,$inlogin)=@_;

  if (! $inkey) { $inkey="NOMACHINE"; }
  $inlogin=$user if ( ! $inlogin);
  my ($machine,$parm,$login,$password);

  common_read_netrc();  # make sure cache is read
  my $key="$inkey-$inlogin";

  if ( $netrc{$key} ) {
    my $q=$netrc{$key};
    return ( 
      $key,
      $q->{machine},
      $q->{parm},
      $q->{login},
      $q->{password},
    );
  }
  
  for my $key (sort keys %netrc) {
    if ( $key =~ /^$inkey.*-$inlogin.*/i ) {
      my $q=$netrc{$key};
      return ( 
        $key,
        $q->{machine},
        $q->{parm},
        $q->{login},
        $q->{password},
      );
    }
  }
  return ( undef,undef,undef,undef,undef );
}

sub confirm {
  my ($autoconfirm, $cmd) =@_;
  if ($autoconfirm) { return 1; }

  while(1) {
    print "$cmd";
    my $ans=<STDIN>;
    chomp $ans;
    if ( !$ans ) { $ans = "y"; }
    if ( $ans eq "q" ) { print "Aborted\n"; exit(1); } 
    if ( $ans eq "y" ) { return 1;}
    if ( $ans eq "n" ) { print "Cancelled - no action\n"; return 0; }
  }
}

sub verbose { if ($opt_verbose >=1 ) { print _trace()."$VERBOSETAG: " . shift . "\n"; } }
sub notice { print _trace()."$NOTICETAG: " . shift . "\n"; }
sub error { print _trace()."$ERRORTAG: " . shift . "\n"; }
sub warning { print _trace()."$WARNINGTAG: " . shift . "\n"; }
sub debug { if ($opt_debug >=1 ) { print _trace()."$DEBUGTAG: " . shift . "\n"; } }
sub debug2 { if ($opt_debug >= 2 ) { print _trace()."$DEBUGTAG: DUMPER:\n"; print Dumper shift; } }
sub usage { 
  system ( "sed -n '/^# Usage:/,/^# -/p' $THISSCRIPT");
  return 0;
}

# _trace used via verbose, so show caller of verbose()
sub _trace {
  return if ( $opt_trace == 0 );
  my ($package, $filename, $line, $subroutine, $hasargs, $wantarray, $evaltext, $is_require, $hints, $bitmask) = caller(1);
  my ($package1, $filename1, $line1, $subroutine1, $hasargs1, $wantarray1, $evaltext1, $is_require1, $hints1, $bitmask1) = caller(2);
  return "${C_TRC}$$-$filename\[$line\] ${subroutine1}${C_NORM} : "
}

sub stack {
        my $i=0;
        my ($package, $filename, $line, $subroutine, $hasargs,
                $wantarray, $evaltext, $is_require, $hints, $bitmask);
        while ($i < 100)
        {
                ($package, $filename, $line, $subroutine, $hasargs,
                        $wantarray, $evaltext, $is_require, $hints, $bitmask) = caller($i);
                if ( ! defined $filename || ! defined $line || ! defined $subroutine )
                {       last;
                }
                print "     Stack frame $i: $filename [ $line ] $subroutine \n";
                $i++;
        }
        return 1;
}

sub trace {
  return if ( $opt_trace == 0 );
  print( _trace( join( " ", @_ )). "\n");
}
# trace point quick & dirty
sub tp {
  my $a=$opt_trace;
  $opt_trace=3;
  print( _trace().  join( " ", @_ ). "\n");
  $opt_trace=$a
}

sub center($$$) {
        my $txt=shift;
        my $border=shift || $TAG;
        my $padc=shift; 
        if (! defined $padc ) {$padc=" "; } 
        my $maxl=shift; 
        if (! defined $maxl ) {$maxl=80; } 

        my $nctxt=$txt;
        $nctxt =~ s/.\[[0-9;]*m//g;
        my $ncborder=$border;
        $ncborder =~ s/.\[[0-9;]*m//g;

        my $nr=length( $nctxt);
        if ( $nr % 2 == 1 ) {
                $txt="$txt$padc";            # make even sized
                $nr++;
        }
        my $max=$maxl - 2 * length($ncborder);
        my $nrpad=($max - $nr)/2;
        my $pad=sprintf( "$padc" x ${nrpad} );
        return "${border}${pad}${txt}${pad}${border}";
}


sub debug3hex {
    if ( $opt_debug < 3) {return; }
    my $offset = 0;
    my(@array,$format);
    foreach my $data (unpack("a16"x(length($_[0])/16)."a*",$_[0])) {
        my($len)=length($data);
        if ($len == 16) {
            @array = unpack('N4', $data);
            $format="0x%08x (%05d)   %08x %08x %08x %08x   %s\n";
        } else {
            @array = unpack('C*', $data);
            $_ = sprintf "%2.2x", $_ for @array;
            push(@array, '  ') while $len++ < 16;
            $format="0x%08x (%05d)" .
               "   %s%s%s%s %s%s%s%s %s%s%s%s %s%s%s%s   %s\n";
        } 
        $data =~ tr/\0-\37\177-\377/./;
        printf $format,$offset,$offset,@array,$data;
        $offset += 16;
    }
}


sub htmlencodePasswd {
  my $x=shift;
  $x=~ s/\%/\%25/g;   # percent first!
  $x=~ s/\#/\%23/g;       
  $x=~ s/\!/\%21/g;
  $x=~ s/\$/\%24/g;
  $x=~ s/\&/\%26/g;
  $x=~ s/\'/\%27/g;
  $x=~ s/\(/\%28/g;
  $x=~ s/\)/\%29/g;
  $x=~ s/\*/\%2A/g;
  $x=~ s/\+/\%2B/g;
  $x=~ s/\,/\%2C/g;
  $x=~ s/\//\%2F/g;
  $x=~ s/\:/\%3A/g;
  $x=~ s/\;/\%3B/g;
  $x=~ s/\=/\%3D/g;
  $x=~ s/\?/\%3F/g;
  $x=~ s/\@/\%40/g;
  $x=~ s/\[/\%5B/g;
  $x=~ s/\]/\%5D/g;
  return $x;
}

sub _curl($$) {
    my ($request,$url) = @_;
    my $cmd;
    my $returnJson;
    my @pages=();
    my $nextPageStart;
    my $limit;

    my $isLastPage = 1;
    do {
      my $args = "--insecure --request '$request' --url '$curlbaseurl$url'" ;

      if (defined $nextPageStart) {
        $args .= "?start=$nextPageStart\\&limit=$limit";
      }
      $cmd="curl $curlparm $args 2>/dev/null";  # silent

      debug($cmd);
      my $response=`$cmd`;
      if ( $^O eq "os390") { 
          # YAT-1833
          if ( $response =~ /\*/ ) {
            # print "$WARNINGTAG: response contains '*' ==> replaced by '#'\n";
            $response =~ s/\*/x/g;
          }
      }
      debug("--hexdata--");
      debug3hex($response);
      debug("--data--");
      debug2($response);

      debug("--json--");

      my $json;
      eval {
        $json= decode_json $response;
     };
     if ($@) {
        error "access to GIT server='$curltarget' failed for user='$user':\n";
        my $x=$cmd; $x=~ s/:[^:\@]*\@/:<password>\@/;

        $cmd="curl -v $args 2>&1";  # silent
        my $fullresponse=`$cmd`;
        error "request cmd: $x\n";
        error "response: $fullresponse\n"; 
        if ( $fullresponse =~  /< HTTP\/2 401/ ) {
            error "HTTP 401 : Unauthorized\n";
        } elsif ( $fullresponse =~  /< HTTP\/2 403/ ) {
            error "HTTP 403 : Forbidden";
        } elsif ( $fullresponse =~  /< HTTP\/2 404/ ) {
            error "HTTP 404 : Not found";
        } else {
            error "cmd='$cmd' error processing response: $@\n";
        }
        exit(1);
     }
      debug2($json);
      debug("----");
      if ( ref($json) eq "HASH" && defined $json->{isLastPage} ) {
        debug "PAGINATED! last=". $json->{isLastPage} . " start=".  $json->{start} . " nextPageStart=" . $json->{nextPageStart} ;
        # 
        my $p=$json->{values};
        for my $page (@$p) {
          push @pages, $page;
        }
        $returnJson=\@pages;
        if ( $json->{isLastPage} == 0 ) {   # JSON false
          $isLastPage=0;
          $nextPageStart=$json->{nextPageStart};
          $limit=$json->{limit};
          if ($limit < 1000) { $limit=1000};
        } else {
          $isLastPage=1;
        }
      } else { 
        $returnJson=$json;
      }
    } while ( ! $isLastPage );
    return $returnJson;
}

#=======================================================================#
#==END gutspl injection part == do not alter
#=======================================================================#
#==EPILOGUE sample toolscript
#=======================================================================#
#==MAIN==
#-------------------------------------------------------------------------#
#--- help ?
# zef help [--all|zef|<command>]
#   Display help information.
#   Prints info between '#---<space>[topic]$" and "#---" markers.
#   Display help information.
#---
#-------------------------------------------------------------------------#
sub cmd_help {
 return common_help(@_);
}
#-------------------------------------------------------------------------#
#--- nbg
# zef nbg <bible>
#    extracts the <bible>
#
#    The zef.GET.header file can be created by 
#    - in een browser, access https://debijbel.nl/bijbel/BGT/
#    - in browser webdevelopment tools, find the GET request, copy the request header
#
# example:
#    zef nbg NBV
#---
#-------------------------------------------------------------------------#
sub cmd_nbg {
  my @args=@_;
  my $reset=0;
  my $bible;

  while ($args[0] =~ /^-/) {
    if ( $args[0] eq "-reset" ) {
        $reset=1;
        shift @args;
    } else {
      error("unknown option: $args[0]");
      return 1;
    }
  }
  if ( $args[0] ) { $bible=$args[0]; shift @args; }
  if ( $args[0] ) { error("unknown option: $args[0]" ); return 1; }
  if ( ! $bible ) { error("no bible specified"); return 1; }
  my $zefdir="zef.$bible" ;
  my $topdir=getcwd();
  my $header="$topdir/zef.GET.header";
  my $template="$topdir/zef.$bible.TEMPLATE.xml";
  my $zefbible="$topdir/zef.$bible.xml";
  if ( -f $zefbible ) { unlink $zefbible; }

  if ( ! -f $header ) {
    error("no file: $header"); return 1;
  } else {
    verbose( "using $header");
  }
  if ( ! open(HEADER,$header) ) { error "cannot open $header: $!\n"; }
  @GETheader=<HEADER>;
  close HEADER;

  if ( ! -f $template ) {
    error("no file: $template"); return 1;
  } else {
    verbose( "using $template");
  }
  if ( ! open(TEMPLATE,$template) ) { error "cannot open $template $!\n"; }
  @Template=<TEMPLATE>;
  close TEMPLATE;

  if ($reset) {
    if ( -d $zefdir ) {
      rmtree($zefdir) || return 1; 
    }
  }
  if ( ! -d $zefdir ) {
    mkdir($zefdir) || return 1;
  }
  chdir($zefdir) || return 1;
  notice "in $zefdir";
  
  my $rval=0;
  notice ("get bible: $bible -> $zefbible");
  if ( -f $zefbible ) {
    notice "Zefania bible: $zefbible already exists";
    return 0;
  }

  if ( ! open( XML, ">:encoding(UTF-8)","$zefbible" ) ){  error "cannot open $zefbible"; return 1; }

  print XML @Template;

  my $booknr=0;
  for my $books (@books) {
    $booknr++;
    my $chap=0;
    my $book=$books; $book =~ s/:.*//;
    my $bookname=$books; $bookname =~ s/^[^:]*://; $bookname=~ s/:.*//;
    my $max=$books; $max =~ s/.*://;
    print XML "  <BIBLEBOOK bnumber=\"$booknr\" bname=\"$booknr $book\" bsname=\"$booknr$book\">\n";

    while ( $chap < $max ) {
      $chap++;
      print XML "   <CHAPTER cnumber=\"$chap\">\n" ;

      my $zefbook="$bible.$book.$chap.html";
      if ( -f $zefbook ) {
        notice "$zefbook already exists" ;
      } else {
        wget_cmd ( "$nbgurl/bijbel/$bible/$book.$chap", "$zefbook"  );
      }
      notice( "file://" . realpath($zefbook));

      if ( process_file($bookname, $chap, $zefbook, $zefbible) != 0 ) { return 1;};
      print XML "   </CHAPTER>\n" ;
    }
    print XML "  </BIBLEBOOK>\n";
  }
  print XML "</XMLBIBLE>\n";
  close XML;
  
  if ( -f $zefbible ) {
    print "${C_OK}OK${C_NORM}\n" ;
  } else {
    print "${C_NOK}NOT OK${C_NORM}\n" ;
  }
  return $rval;
}

sub wget_cmd {
  my ($url,$ofile)=@_;

  my $cmd;
  $cmd="wget --no-check-certificate -O $ofile" ;
  $cmd.=" --compression=gzip" ;
  for my $h (@GETheader) {
    if ($h =~ /^GET/) { next; }
    chomp $h;
    if ($h =~ /^$/) { next; }
    $cmd .= " --header '$h'";
  }
  $cmd.=" $url" ;
  notice( "cmd: $cmd");
  system("$cmd");
  if ($? != 0) { return 1; }

  return 0;
}

sub doinit() {
  if (common_init() != 0) {
      doexit(1);
  };

  my $cmd="nslookup $nbghost | grep ^Address | awk '{print \$2}' | grep -v -e \"#\" -e :";
  verbose "$cmd" ;
  $nbgip=`$cmd`;
  if ( ! $nbgip ) { error("cannot get ip for $nbghost"); doexit(1);}
  $nbgip =~ s/[\r\n]//g;
  $nbgurl="https://$nbgip";
  return 0;
}
sub process_file {
  my ($bookname, $chap, $html)=@_;
  notice "process $html" ;

  my $xhtml="X-$html";
  if ( ! -f $xhtml ) {
    if ( ! open( HTML, "$html" ) ){  error "cannot open $html"; return 1; }
    if ( ! open( XHTML, ">$xhtml" ) ){  error "cannot open $xhtml"; return 1; }

    my $stage=0;
    my $nextstage=0;
    print XHTML "<html><body>";
    while (my $line = <HTML> ){
      if ($stage == 0) {
        if ($line =~ /<app-bible-passage/) {
          $stage=1;
          $line =~ s/.*<app-bible-passage/<app-bible-passage/;
        }
      }
      if ($stage == 1) {
        if ($line =~ /<\/app-bible-passage/) {
          $line =~ s/<\/app-bible-passage.*/<\/app-bible-passage>/;
          $nextstage=0;
        }
      }
      if ($stage == 1) {
        print XHTML $line;
        $stage=$nextstage;
      }
    }
    print XHTML "</body></html>";
    close HTML;
    close XHTML;
  }

  my $dom = XML::LibXML->load_xml(location => "$xhtml" );


  foreach my $passage ($dom->findnodes('//app-bible-passage')) {
      my @attrs=$passage->attributes();
      foreach my $attr (@attrs) {
        next if ( $attr !~ /^ *data-chapter-string/ );
        my $v=$attr; $v=~ s/.*="//g; $v=~ s/"//g;
      }
      foreach my $span ($passage->findnodes('//span')) {
        my @attrs=$span->attributes();
        foreach my $attr (@attrs) {
          next if ( $attr !~ /^ *data-verse-org-id/ );
          my $v=$attr; $v=~ s/.*="//g; $v=~ s/"//g;
          $v=~ s/.*\.//;
          print XML "<VERS vnumber=\"$v\">". $span->to_literal()."</VERS>\n";
        }
      }
  }
}


sub doexit($) {
  exit(1);
}

sub zefMain {
  while ( $ARGV[0] ) {
      my $cmd= $ARGV[0]; 
      shift @ARGV;
      if ( $cmd eq "help" ) { return cmd_help( @ARGV ); 
      } elsif ( $cmd eq "nbg" ) { return cmd_nbg( @ARGV ); 
      } else { error("unknown command '$cmd'"); return(1); 
      }
  }
  return 0;
}
while ( $ARGV[0] =~ /^-/ ) {
  if ( common_option( $ARGV[0] ) == 0 ) {
      shift @ARGV;
      next;
  }
  error("unknown common option: $ARGV[0]");
  usage();
  exit 1;
}
doinit();
verbose("zefMain ". join( " ", @ARGV ));
doexit( zefMain(@ARGV) );

