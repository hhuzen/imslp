#!/bin/env perl
#=======================================================================#
#==PROLOGUE sample toolscript
#=======================================================================#


use XML::LibXML;
# sudo apt-get install zlib1g-dev libxml2-dev
# sudo cpan install XML::LibXML

#--- zef
# zef - create zefania bible xml file 
#     https://sourceforge.net/projects/zefania-sharp/files/Bibles/
#
#     developed,tested on UBUNTU, required tools:
#      wget nslookup
#
# DISCLAIMER: this tool can be used to extract bible-data from websites.
#     You must obey to the copyright and licensing rules that apply to that data.
#     This tool in no way gives any right for storing or using that data.
#
# Usage:
#   zef [common options] <zefcommand> [command options]
#
# zefcommand:
#   zef help
#   zef nbg               # extract from nbg website
#
# Common options:
#   -v|--verbose : verbose
#   -t|--trace : trace (verbose printing script-line number)
#   -bw|--bw : no colors
#   -a|--autoconfirm : selects default choices
#   -noggc|--noggc : no use of GGC (if set defaults to GUTSPL_NOGGC)
# -
#
# Example:
#    zef help
#---

# unimplemented (vs gutsh)
#   -env=<file> : file to source
#   -ggc=<ggc> : GGC selection to use

# use common functions
# TAG is *<toolname in GGC>*
my $TAG="*zef*";
my $nbghost="debijbel.nl";
my $nbgip;
my $nbgurl;


#=======================================================================#
#==gutspl=CHECKSUM=29149
#=======================================================================#
#==BEGIN gutspl injection part == do not alter
#=======================================================================#

BEGIN { $| = 1 }
use strict;
use Term::ANSIColor;
use Cwd 'realpath';
use Cwd;
use File::Basename;
use File::Path;
use Sys::Hostname;
use JSON::PP;
use Data::Dumper;
use POSIX qw(strftime);
use Net::Domain qw(hostfqdn);

my $curlbaseurl="";
my $curlparm="";
my $curltarget="";

my $THISSCRIPT=realpath( $0 );
my $THISSCRIPTDIR=dirname( ${THISSCRIPT});
$ENV{PATH}.=":$THISSCRIPTDIR";

my $TOOLARGS=join( " ", @ARGV);
my $TMP=$ENV{TMP} || "/tmp";
my $C_NORM;
my $C_NOT;
my $C_VER;
my $C_DEB;
my $C_ERR;
my $C_WRN;
my $C_ASK;
my $C_TRC;
my $C_OK;
my $C_NOK;
my $C__UP;
my $C_DWN;
my $user=$ENV{USER} || $ENV{USERNAME} || "?user" ;
$user=lc($user);

my $COMMON_ARGS="";
my $opt_bw=0;
my $confirm_answer="";
my $opt_ac=0;
my $opt_noggc=0;
if ( defined $ENV{"GUTSPL_NOGGC"} ) {$opt_noggc=$ENV{"GUTSPL_NOGGC"}; }
my $opt_ggc="";
my $opt_guts_platform="";
my $opt_env;
if ( $ENV{GUTPL_NOGGC}) { $opt_noggc=$ENV{GUTPL_NOGGC}; }
my $ERRORTAG="$TAG ERROR:";
my $WARNINGTAG="$TAG WARNING:";
my $NOTICETAG="$TAG NOTICE:";
my $VERBOSETAG="$TAG VERBOSE:";
my $DEBUGTAG="$TAG";
my $ASKTAG="$TAG";

my $opt_debug=$ENV{GUTSPL_DEBUG} || 0;
my $opt_verbose=$ENV{GUTSPL_VERBOSE} || 0;
my $opt_trace=$ENV{GUTSPL_TRACE} || 0;
# returns 0 if common option processed - cannot shift
sub common_option($) {
    my $opt=shift;

    if ( "$opt" eq "-bw" || "$opt" eq "--bw" ){
      $COMMON_ARGS="$COMMON_ARGS -bw";
      $opt_bw=1;
      return 0;
    } elsif( "$opt" eq "-v" || "$opt" eq "--verbose" ) {
      $opt_verbose=$opt_verbose + 1;
      $COMMON_ARGS="$COMMON_ARGS -v";
      return 0;
    } elsif( "$opt" eq "-d" || "$opt" eq "--debug" ) {
      $opt_debug=$opt_debug + 1;
      $COMMON_ARGS="$COMMON_ARGS -d";
      return 0;
    } elsif( "$opt" eq "-t" || "$opt" eq "--trace" ) {
      $opt_verbose=$opt_verbose + 1;
      $opt_trace=$opt_trace + 1;
      $COMMON_ARGS="$COMMON_ARGS -t";
      return 0;
    } elsif( "$opt" eq "-a" || "$opt" eq "--autoconfirm" ) {
      $COMMON_ARGS="$COMMON_ARGS -a";
      $opt_ac=1;
      return 0;
    } elsif( "$opt" eq "-na" ) {
      $COMMON_ARGS="$COMMON_ARGS -na";
      $opt_ac=0;
      return 0;
    } elsif( "$opt" eq "-noggc" || "$opt" eq "--noggc" ) {
      $COMMON_ARGS="$COMMON_ARGS -noggc";
      $opt_noggc=1;
      return 0;
    } elsif( "$opt" =~ "-env=" ) {
      $COMMON_ARGS="$COMMON_ARGS $opt";
      $opt_env=$opt;
      $opt_env =~ s/^[^=]*=//;
      error( "oeps no sourcing" ) && exit 1; 
      #. $opt_env || exit 1
      return 0;
    } elsif( "$opt" =~ "-ggc=" )  {
      $COMMON_ARGS="$COMMON_ARGS $opt";
      $opt_ggc=$opt;
      $opt_ggc =~ s/^[^=]*=//;
      $ENV{GGC_WORLD}="$opt_ggc";
      return 0;
    } elsif( "$opt" =~ "-guts_platform=" )  {
      $opt_guts_platform=$opt;
      $opt_guts_platform=~ s/^[^=]*=//;
      $ENV{GUTS_PLATFORM}="$opt_guts_platform";
      return 0;
    } elsif( "$opt" eq "-?" )  {
      usage();
      exit 0;
    }
    return 1
}

sub common_init() {
  my ($bw) = @_;
  debug("init");

  if ( ! $ENV{TF_ORGANIZATION} ) {
    my $fq=hostfqdn(); my $org=$fq; $org=~ s/\.[^\.]*$//; $org=~ s/^.*\.//;  $ENV{TF_ORGANIZATION}=$org;
  }
  if ( ! $ENV{TF_DOMEXT} ) {
    my $fq=hostfqdn(); my $domext=$fq; $domext=~ s/^.*\.//;  $ENV{TF_DOMEXT}=$domext;
  }
  if ( ! $ENV{TF_GITPROJ} ) {
    $ENV{TF_GITPROJ}="gitproject";
  }

  $C_NORM=color("reset");
  $C_ASK=color("black on_green");

  $C_VER=color("bold white on_blue");
  $C_NOT=color("bold cyan on_blue");
  $C_DEB=color("bold white on_magenta");
  $C_ERR=color("bold white on_red");
  $C_WRN=color("bold white on_yellow");
  $C__UP=color("bold white on_magenta");
  $C_DWN=color("white on_white");
  $C_OK=color("bold white on_green");
  $C_NOK=color("bold white on_red");
  $C_TRC=color("bold red on_yellow");

  if ($bw) {
   $C_NORM='';
   $C_VER='';
   $C_NOT='';
   $C_DEB='';
   $C_ERR='';
   $C_WRN='';
   $C_ASK='';
   $C__UP='';
   $C_DWN='';
   $C_OK='';
   $C_NOK='';
   $C_TRC='';
  }
  $VERBOSETAG=$C_VER.$TAG.$C_NORM. " ";
  $NOTICETAG=$C_NOT.$TAG.$C_NORM. " ";
  $DEBUGTAG=$C_DEB.$TAG.$C_NORM. " ";
  $ERRORTAG=$C_ERR.$TAG.$C_NORM. " ERROR";
  $WARNINGTAG=$C_WRN.$TAG.$C_NORM. " WARNING";
  $ASKTAG=$C_ASK.$TAG.$C_NORM;

  if ( $opt_verbose ) {
    my $MYTAG="${C__UP}*${C_NORM}";
    my @NOW=localtime();
    my $date= strftime('%Y-%m-%dT%H:%M:%S', @NOW);

    my $line=center( "started at $date","$TAG","*");
    print( "${C__UP}$line${C_NORM}\n");
    $line="${C_TRC} C_TRC ${C_ERR} C_ERR ${C_WRN} C_WRN ${C_ASK} C_ASK ${C_DWN} C_DWN ${C__UP} C__UP ${C_VER} C_VER ${C_NOT} C_NOT ${C_OK} C_OK ${C_NOK} C_NOK ${C_NORM} C_NORM";
    print( "$MYTAG${C__UP}$line${C_NORM}\n");
    print( "$MYTAG  HOST=". hostname(). " PID=$$ PPID=". getppid()."\n");
    print( "$MYTAG  USER=$user\n" );
    #print( "$MYTAG  uname -a="$(uname -a)
    print( "$MYTAG  PATH=$ENV{PATH}\n");
    print( "$MYTAG  SCRIPT=". realpath($0)."\n");
    print( "$MYTAG  ARGS=${TOOLARGS}\n");
    print( "$MYTAG  \$^O=$^O\n");
    for my $k (qw (GUTS_PLATFORM GGC_HOME GGC_WORLD TMP TEMP)) {
      print( "$MYTAG  $k=$ENV{$k}\n");
    }
    $line=center("***");
    print( "${C__UP}$line${C_NORM}\n");
  }


  for my $e (qw( http_proxy HTTP_PROXY https_proxy HTTPS_PROXY)) {
    if ( $ENV{$e} ) {
      notice("$e=$ENV{$e}");
    }
  }
  if ( $opt_verbose ) {
    my $line=center("***");
    my $MYTAG="${C__UP}*${C_NORM}";
    print( "${C__UP}$line${C_NORM}\n");
    for my $k (qw (TF_ORGANIZATION TF_DOMEXT TF_GITPROJ )) {
      print( "$MYTAG  $k=$ENV{$k}\n");
    }
    print( "${C__UP}$line${C_NORM}\n");
  }

  if ( import_ggc() !=0 ) {return 1;}


  return 0;  
}

sub import_ggc() {
    if ( ! "$ENV{GGC_GITPROJ}" ) { $ENV{GGC_GITPROJ}=$ENV{TF_GITPROJ}; }
    if ( ! "$ENV{GGC_HOME}" && -d "$ENV{HOME}/GGC" ) { $ENV{GGC_HOME}="$ENV{HOME}/GGC"; }
    if ( ! "$ENV{GGC_HOME}" && -d "$ENV{HOME}/HOUSTON/$ENV{GGC_GITPROJ}-ggc-global" ) { $ENV{GGC_HOME}="$ENV{HOME}/HOUSTON/$ENV{GGC_GITPROJ}-ggc-global"; }

    if ( defined $ENV{GGC_HOME} && $ENV{GGC_HOME} ne "" ) {
      if ( -d "$ENV{GGC_HOME}" ) {
        $ENV{GGC_WORLD_SELECTED}=undef;
        my $GGCTOOL=$TAG;  $GGCTOOL=~s/\*//g;
        verbose("GGC import : $ENV{GGC_HOME}/ggc.sh show $GGCTOOL -perlvars");
        if ( "$GGCTOOL" ) { 
           my $ggcinfo=`$ENV{GGC_HOME}/ggc.sh show $GGCTOOL -perlvars`;
           my $rc=$?;
           if ( "$ggcinfo" =~ /tool .* is unknown/ ) {
             verbose("GGC import SKIPPED: $ggcinfo");
           } elsif ($rc != 0) {
             verbose("GGC import NOT OK: $ggcinfo");
             return 1;
           } else {
             verbose("GGC import OK");
             my @l=split( /\n/,$ggcinfo );
             $ggcinfo="";
             for my $l (@l) {
                verbose("GGC import: $l");
                if ($l =~ /^#/) { next; }
                if ($l =~ /^GGC[ :]/ ) { warn($l); next; }
                $ggcinfo.="$l\n";
             }
             eval "$ggcinfo";
             if ($@) {
                error( "GGC import failed: $@" );
                return 1
             }
           }
        }
      } else {
        warning("GGC_HOME='$ENV{GGC_HOME}' is not a directory");
      }
    } else {
        verbose("import_ggc: GGC_HOME is not set: skipped");
    }
    return 0
}


sub common_help {
 my $topic=shift;
 if ( $topic =~ /-*(all|ALL)/ ) {
        system("sed -n '/^#--- /,/^#---\$/p' ${THISSCRIPT}");
        return 0;
 }

 if ( ! $topic ) {
   usage();
   $topic="help";
 }
 system("sed -n '/^#---.*${topic}.*\$/,/^#---\$/p' ${THISSCRIPT} | grep -v \"^#---\"");
 return 0;
}

# read cache netrc info
my %netrc=();
my $netrc_done=0;
sub common_read_netrc() {
  if ( $netrc_done ==1 ) { return \%netrc; }

  my @ee=();
  if ( open NETRC, $ENV{HOME}."/.netrc") {
          @ee=<NETRC>;
          close NETRC;
  }
  my ($machine,$login,$pass);
  for my $e (@ee) {
            chomp $e;
            next if ($e =~/^[ #]/);
            next if ($e =~/^[ ]*$/);
            $machine=$e;
            $machine =~ s/.*machine\s+//;
            $machine =~ s/\s.*//;

            $pass=$e;
            $pass =~ s/.*password\s+//;
            $pass =~ s/\s.*//;

            $login=$e;
            $login =~ s/.*login\s+//;
            $login =~ s/\s.*//;


	    my %entry=();
	    $entry{machine}=$machine;
	    $entry{login}=$login;
	    $entry{password}=$pass;
            my $parm =$machine;
            $parm =~ s/.*=//;
	    $entry{parm}=$parm;
            my $mkey="$machine";
            $mkey =~ s/=.*//;
            next if ( ! $mkey );
            my $mlkey="$mkey-$login";
	    $netrc{$mlkey}=\%entry;
            # if ( ! $netrc{$mkey} ) {
            #  $netrc{$mkey}=\%entry;
            #}
  }
  return \%netrc;
}
# get netrc entry fuzzy matched (case insensitive, prefix (like simple host name)
sub common_get_netrc {
  my ($inkey,$inlogin)=@_;

  if (! $inkey) { $inkey="NOMACHINE"; }
  $inlogin=$user if ( ! $inlogin);
  my ($machine,$parm,$login,$password);

  common_read_netrc();  # make sure cache is read
  my $key="$inkey-$inlogin";

  if ( $netrc{$key} ) {
    my $q=$netrc{$key};
    return ( 
      $key,
      $q->{machine},
      $q->{parm},
      $q->{login},
      $q->{password},
    );
  }
  
  for my $key (sort keys %netrc) {
    if ( $key =~ /^$inkey.*-$inlogin.*/i ) {
      my $q=$netrc{$key};
      return ( 
        $key,
        $q->{machine},
        $q->{parm},
        $q->{login},
        $q->{password},
      );
    }
  }
  return ( undef,undef,undef,undef,undef );
}

sub confirm {
  my ($autoconfirm, $cmd) =@_;
  if ($autoconfirm) { return 1; }

  while(1) {
    print "$cmd";
    my $ans=<STDIN>;
    chomp $ans;
    if ( !$ans ) { $ans = "y"; }
    if ( $ans eq "q" ) { print "Aborted\n"; exit(1); } 
    if ( $ans eq "y" ) { return 1;}
    if ( $ans eq "n" ) { print "Cancelled - no action\n"; return 0; }
  }
}

sub verbose { if ($opt_verbose >=1 ) { print _trace()."$VERBOSETAG: " . shift . "\n"; } }
sub notice { print _trace()."$NOTICETAG: " . shift . "\n"; }
sub error { print _trace()."$ERRORTAG: " . shift . "\n"; }
sub warning { print _trace()."$WARNINGTAG: " . shift . "\n"; }
sub debug { if ($opt_debug >=1 ) { print _trace()."$DEBUGTAG: " . shift . "\n"; } }
sub debug2 { if ($opt_debug >= 2 ) { print _trace()."$DEBUGTAG: DUMPER:\n"; print Dumper shift; } }
sub usage { 
  system ( "sed -n '/^# Usage:/,/^# -/p' $THISSCRIPT");
  return 0;
}

# _trace used via verbose, so show caller of verbose()
sub _trace {
  return if ( $opt_trace == 0 );
  my ($package, $filename, $line, $subroutine, $hasargs, $wantarray, $evaltext, $is_require, $hints, $bitmask) = caller(1);
  my ($package1, $filename1, $line1, $subroutine1, $hasargs1, $wantarray1, $evaltext1, $is_require1, $hints1, $bitmask1) = caller(2);
  return "${C_TRC}$$-$filename\[$line\] ${subroutine1}${C_NORM} : "
}

sub stack {
        my $i=0;
        my ($package, $filename, $line, $subroutine, $hasargs,
                $wantarray, $evaltext, $is_require, $hints, $bitmask);
        while ($i < 100)
        {
                ($package, $filename, $line, $subroutine, $hasargs,
                        $wantarray, $evaltext, $is_require, $hints, $bitmask) = caller($i);
                if ( ! defined $filename || ! defined $line || ! defined $subroutine )
                {       last;
                }
                print "     Stack frame $i: $filename [ $line ] $subroutine \n";
                $i++;
        }
        return 1;
}

sub trace {
  return if ( $opt_trace == 0 );
  print( _trace( join( " ", @_ )). "\n");
}
# trace point quick & dirty
sub tp {
  my $a=$opt_trace;
  $opt_trace=3;
  print( _trace().  join( " ", @_ ). "\n");
  $opt_trace=$a
}

sub center($$$) {
        my $txt=shift;
        my $border=shift || $TAG;
        my $padc=shift; 
        if (! defined $padc ) {$padc=" "; } 
        my $maxl=shift; 
        if (! defined $maxl ) {$maxl=80; } 

        my $nctxt=$txt;
        $nctxt =~ s/.\[[0-9;]*m//g;
        my $ncborder=$border;
        $ncborder =~ s/.\[[0-9;]*m//g;

        my $nr=length( $nctxt);
        if ( $nr % 2 == 1 ) {
                $txt="$txt$padc";            # make even sized
                $nr++;
        }
        my $max=$maxl - 2 * length($ncborder);
        my $nrpad=($max - $nr)/2;
        my $pad=sprintf( "$padc" x ${nrpad} );
        return "${border}${pad}${txt}${pad}${border}";
}


sub debug3hex {
    if ( $opt_debug < 3) {return; }
    my $offset = 0;
    my(@array,$format);
    foreach my $data (unpack("a16"x(length($_[0])/16)."a*",$_[0])) {
        my($len)=length($data);
        if ($len == 16) {
            @array = unpack('N4', $data);
            $format="0x%08x (%05d)   %08x %08x %08x %08x   %s\n";
        } else {
            @array = unpack('C*', $data);
            $_ = sprintf "%2.2x", $_ for @array;
            push(@array, '  ') while $len++ < 16;
            $format="0x%08x (%05d)" .
               "   %s%s%s%s %s%s%s%s %s%s%s%s %s%s%s%s   %s\n";
        } 
        $data =~ tr/\0-\37\177-\377/./;
        printf $format,$offset,$offset,@array,$data;
        $offset += 16;
    }
}


sub htmlencodePasswd {
  my $x=shift;
  $x=~ s/\%/\%25/g;   # percent first!
  $x=~ s/\#/\%23/g;       
  $x=~ s/\!/\%21/g;
  $x=~ s/\$/\%24/g;
  $x=~ s/\&/\%26/g;
  $x=~ s/\'/\%27/g;
  $x=~ s/\(/\%28/g;
  $x=~ s/\)/\%29/g;
  $x=~ s/\*/\%2A/g;
  $x=~ s/\+/\%2B/g;
  $x=~ s/\,/\%2C/g;
  $x=~ s/\//\%2F/g;
  $x=~ s/\:/\%3A/g;
  $x=~ s/\;/\%3B/g;
  $x=~ s/\=/\%3D/g;
  $x=~ s/\?/\%3F/g;
  $x=~ s/\@/\%40/g;
  $x=~ s/\[/\%5B/g;
  $x=~ s/\]/\%5D/g;
  return $x;
}

sub _curl($$) {
    my ($request,$url) = @_;
    my $cmd;
    my $returnJson;
    my @pages=();
    my $nextPageStart;
    my $limit;

    my $isLastPage = 1;
    do {
      my $args = "--insecure --request '$request' --url '$curlbaseurl$url'" ;

      if (defined $nextPageStart) {
        $args .= "?start=$nextPageStart\\&limit=$limit";
      }
      $cmd="curl $curlparm $args 2>/dev/null";  # silent

      debug($cmd);
      my $response=`$cmd`;
      if ( $^O eq "os390") { 
          # YAT-1833
          if ( $response =~ /\*/ ) {
            # print "$WARNINGTAG: response contains '*' ==> replaced by '#'\n";
            $response =~ s/\*/x/g;
          }
      }
      debug("--hexdata--");
      debug3hex($response);
      debug("--data--");
      debug2($response);

      debug("--json--");

      my $json;
      eval {
        $json= decode_json $response;
     };
     if ($@) {
        error "access to GIT server='$curltarget' failed for user='$user':\n";
        my $x=$cmd; $x=~ s/:[^:\@]*\@/:<password>\@/;

        $cmd="curl -v $args 2>&1";  # silent
        my $fullresponse=`$cmd`;
        error "request cmd: $x\n";
        error "response: $fullresponse\n"; 
        if ( $fullresponse =~  /< HTTP\/2 401/ ) {
            error "HTTP 401 : Unauthorized\n";
        } elsif ( $fullresponse =~  /< HTTP\/2 403/ ) {
            error "HTTP 403 : Forbidden";
        } elsif ( $fullresponse =~  /< HTTP\/2 404/ ) {
            error "HTTP 404 : Not found";
        } else {
            error "cmd='$cmd' error processing response: $@\n";
        }
        exit(1);
     }
      debug2($json);
      debug("----");
      if ( ref($json) eq "HASH" && defined $json->{isLastPage} ) {
        debug "PAGINATED! last=". $json->{isLastPage} . " start=".  $json->{start} . " nextPageStart=" . $json->{nextPageStart} ;
        # 
        my $p=$json->{values};
        for my $page (@$p) {
          push @pages, $page;
        }
        $returnJson=\@pages;
        if ( $json->{isLastPage} == 0 ) {   # JSON false
          $isLastPage=0;
          $nextPageStart=$json->{nextPageStart};
          $limit=$json->{limit};
          if ($limit < 1000) { $limit=1000};
        } else {
          $isLastPage=1;
        }
      } else { 
        $returnJson=$json;
      }
    } while ( ! $isLastPage );
    return $returnJson;
}

#=======================================================================#
#==END gutspl injection part == do not alter
#=======================================================================#
#==EPILOGUE sample toolscript
#=======================================================================#
#==MAIN==
#-------------------------------------------------------------------------#
#--- help ?
# zef help [--all|zef|<command>]
#   Display help information.
#   Prints info between '#---<space>[topic]$" and "#---" markers.
#   Display help information.
#---
#-------------------------------------------------------------------------#
sub cmd_help {
 return common_help(@_);
}
#-------------------------------------------------------------------------#
#--- nbg
# zef nbg <bible>
#    extracts the <bible>
#
#    Requires a zef.spec file.
#
#    The zef.spec header be created by 
#    - in een browser, access https://debijbel.nl/bijbel/BGT/
#    - in browser webdevelopment tools, find the GET request, copy the request header
#
# example:
#    zef nbg NBV
#---
#-------------------------------------------------------------------------#

# zef.spec vars
my $BIBLE;
my $BIBLENAME;
#  ABR:bname:bsname:maxchapter
my @BIBLEBOOK;
my %BIBLEBOOK;
my @GETHEADER;

my %BIBLE2BOOKS;          # BIBLE -> @BOOKS
my %BOOK2CHAPTERS;       # BIBLE.BOOK -> @CHAPTERS
my %VALID;
my $zefbible;

sub cmd_nbg {
  my @args=@_;
  my $reset=0;
  my @targets=();

  while ($args[0] =~ /^-/) {
    if ( $args[0] eq "-reset" ) {
        $reset=1;
        shift @args;
    } else {
      error("unknown option: $args[0]");
      return 1;
    }
  }
  @targets=@args;

  if ( doZefSpec() != 0 ) { return 1; };

  my $topdir=getcwd();
  my $zefdir="$topdir/$BIBLE";
  $zefbible="$topdir/$BIBLE.xml";
  if ( @targets == 0 ) { 
    push @targets, $BIBLE;
  };

  if ($reset) {
    if ( -f $zefbible ) { unlink $zefbible; }
    if ( -d $zefdir ) { rmtree($zefdir) || return 1; }   # clean top
  }

  my $rval=0;
  for my $target (@targets) {
    if ( ! $VALID{$target} ) { error( "target=$target is unknown" ); }
    my $valid=$VALID{$target};
    notice "building $target in " . getcwd();
    if ( $valid eq "chapter" ) { 
      $rval=zef_build_chapter( $target ); 
    } elsif ( $valid eq "book" ) { 
      $rval=zef_build_book( $target ); 
    } elsif ( $valid eq "bible" ) { 
      $rval=zef_build_bible( $target ); 
    }
    if ($rval != 0 ) { return 1; }
    chdir($topdir) || return 1;
  }
  return 0;
}

sub  zef_build_chapter {
  my $target=shift;
  my $targetdir=$target;
  $targetdir =~ s/\.[^\.]*$//;   # strip chapternr
  $targetdir =~ s/\./\//g;
  if ( ! -d $targetdir ) { mkpath($targetdir) || return 1; }
  my $rval=0;
  notice "      $target : chapter";
  my $nbg="$targetdir/$target.html";
  if ( -f $nbg ) {
        notice "$nbg already exists" ;
  } else {
        my $x=$target; $x=~ s/\./\//; # only first
        wget_cmd ( "$nbgurl/bijbel/$x", "$nbg"  );
  }
  notice( "file://" . realpath($nbg));

  my $xxml="$targetdir/$target.xml";
  if ( -f $xxml ) {
        notice "$xxml already exists" ;
  } else {
        my $xnbg="$targetdir/X-$target.html";
        my $chap=$target;
        $chap=~  s/^[^\.]*\.[^\.]*\.//g;
        if ( mkxml($chap, $nbg,$xnbg, $xxml) != 0 ) { return 1;};
  }
  return $rval;
}
sub  zef_build_book {
  my $target=shift;
  my $rval=0;
  my $targetdir=$target;
  $targetdir =~ s/\./\//g;
  if ( ! -d $targetdir ) { mkpath($targetdir) || return 1; }
  notice "    $target : book";
  my $pchapters=$BOOK2CHAPTERS{$target};
  for my $chapter (@$pchapters ) {
      $rval=zef_build_chapter( $chapter ); 
      if ($rval != 0 ) { return 1; }
  }
  my $BOOK=$BIBLEBOOK{$target};
  my ($ABR,$BNAME,$BSNAME,$MAX,$BNUMBER) = split(/:/,$BOOK);

  my $xml="$targetdir/$target.xml";
  if ( ! open( XML, ">:encoding(UTF-8)","$xml" ) ){  error "cannot open $xml"; return 1; }
    print XML "  <BIBLEBOOK bnumber=\"$BNUMBER\" bname=\"$BNAME\" bsname=\"$BSNAME\">\n";
    for my $chapter (@$pchapters ) {
      my $chxml="$targetdir/$chapter.xml" ;
      if ( ! open( CHXML, $chxml )) { 
        error "cannot read $chxml"; 
      } else {
        my @ch=<CHXML>;
        close CHXML;
        print XML @ch;
      }
    }
    print XML "  </BIBLEBOOK>\n";
  close XML;
  return $rval;
}
sub  zef_build_bible {
  my $target=shift;
  my $rval=0;
  my $targetdir=$target;
  $targetdir =~ s/\./\//g;
  if ( ! -d $targetdir ) { mkpath($targetdir) || return 1; }
  notice "  $target : bible";
  #build books
  my $pbooks=$BIBLE2BOOKS{$target};
  for my $book (@$pbooks ) {
      $rval=zef_build_book( $book ); 
      if ($rval != 0 ) { return 1; }
  }
  #build xml
  my $xml="$targetdir/$target.xml";
  if ( ! open( XML, ">:encoding(UTF-8)","$xml" ) ){  error "cannot open $xml"; return 1; }
    print XML qq`<?xml version="1.0" encoding="utf-8"?>
<XMLBIBLE xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="zef2005.xsd" version="2.0.1.18" status="v" biblename="$BIBLENAME" revision="3" type="x-bible">
`;

    for my $book (@$pbooks ) {
      my $bookdir=$book;
      $bookdir =~ s/\./\//g;
      my $chxml="$bookdir/$book.xml" ;
      if ( ! open( CHXML, $chxml )) { 
        error "cannot read $chxml"; 
      } else {
        my @ch=<CHXML>;
        close CHXML;
        print XML @ch;
      }
    }
  print XML "</XMLBIBLE>\n";
  close XML;
  return $rval;
}


sub doZefSpec() {
  my $zefspec="zef.spec" ;

  if ( ! -f $zefspec ) {
    error("no file: $zefspec"); return 1;
  } else {
    verbose( "using $zefspec");
  }

  if ( ! open(SPEC,$zefspec) ) { error "cannot open $zefspec $!\n"; }
  while ( my $l = <SPEC> ) {
    # like # BIBLE=
    # like # BIBLENAME=
    if ( $l =~  /^##/ ) { next; }
    if ( $l =~  /^#/ ) {
      chomp $l;
      $l =~ s/^#\s*//g; 
      my $k=$l; $k=~ s/\s*=.*//; 
      my $v=$l; $v=~ s/^[^=]*=\s*//; $v=~ s/\s*$//;
      $ENV{$k}=$v;
      if ( $k eq "BIBLE" ) { $BIBLE=$v; }
      elsif ( $k eq "BIBLENAME" ) { $BIBLENAME=$v; }
      elsif ( $k eq "BIBLEBOOK" ) { push @BIBLEBOOK,$v; }
      else { error(" huh? $k ? "); return 1; };
    } else {
      push @GETHEADER, $l;
    }
  }
  close SPEC;
  my $rval=0;
  for my $v (qw( BIBLE BIBLENAME)) {
    if ( ! defined $ENV{$v} ) { error( "in $zefspec: $v not set" ); $rval=1; }
  }
  if ( @BIBLEBOOK == 0 ) { error( "in $zefspec: no BIBLEBOOK" ); $rval=1; }
  # parse BIBLEBOOK
  
  $VALID{$BIBLE}="bible";
  if ( ! $BIBLE2BOOKS{$BIBLE} ) {
    my @o; $BIBLE2BOOKS{$BIBLE}=\@o;
  }
  my $pbible2books=$BIBLE2BOOKS{$BIBLE};

  my $BNUMBER=0; 
  for my $BOOK (@BIBLEBOOK) {
        my ($ABR,$BNAME,$BSNAME,$MAX) = split(/:/,$BOOK);
        my $book="$BIBLE.$ABR"; 
        $VALID{$book}="book";
        push @$pbible2books, "$book";
        $BNUMBER++;
        $BIBLEBOOK{$BIBLE.".".$ABR}=$BOOK.":".$BNUMBER;

        if ( ! $BOOK2CHAPTERS{$book} ) {
          my @o; $BOOK2CHAPTERS{$book}=\@o;
        }
        my $pbook2chapters=$BOOK2CHAPTERS{$book};
        for ( my $ix=1; $ix <= $MAX; $ix++ ) {
           my $chapter="$BIBLE.$ABR.$ix";    
           $VALID{$chapter}="chapter";
           push @$pbook2chapters, "$chapter";    # order
        }
  }

  print "\%BIBLEBOOK " . Dumper( \%BIBLEBOOK ) . "\n";
  print "\%BIBLE2BOOKS: " . Dumper( \%BIBLE2BOOKS ) . "\n";
  print "\%BOOK2CHAPTERS " . Dumper( \%BOOK2CHAPTERS ) . "\n";
  print "\%VALID " . Dumper( \%VALID ) . "\n";

  return $rval;
}

sub wget_cmd {
  my ($url,$ofile)=@_;
  verbose "$url" ;
  my $cmd;
  $cmd="wget --no-check-certificate -O $ofile" ;
  $cmd.=" --compression=gzip" ;
  for my $h (@GETHEADER) {
    if ($h =~ /^GET/) { next; }
    chomp $h;
    if ($h =~ /^$/) { next; }
    $cmd .= " --header '$h'";
  }
  $cmd.=" $url" ;
  notice( "cmd: $cmd");
  system("$cmd");
  if ($? != 0) { return 1; }

  return 0;
}

sub doinit() {
  if (common_init() != 0) {
      doexit(1);
  };

  my $cmd="nslookup $nbghost | grep ^Address | awk '{print \$2}' | grep -v -e \"#\" -e :";
  verbose "$cmd" ;
  $nbgip=`$cmd`;
  if ( ! $nbgip ) { warning("cannot get ip for $nbghost - set to 0.0.0.0"); $nbgip="0.0.0.0"; }
  $nbgip =~ s/[\r\n]//g;
  $nbgurl="https://$nbgip";
  return 0;
}
sub mkxml {
  my ($chap, $html, $xhtml,$xxml)=@_;
  notice "build $xxml" ;

  if ( ! -f $xhtml ) {
    if ( ! open( HTML, "$html" ) ){  error "cannot open $html"; return 1; }
    if ( ! open( XHTML, ">$xhtml" ) ){  error "cannot open $xhtml"; return 1; }

    my $stage=0;
    my $nextstage=0;
    print XHTML "<html><body>";
    while (my $line = <HTML> ){
      if ($stage == 0) {
        if ($line =~ /<app-bible-passage/) {
          $stage=1;
          $line =~ s/.*<app-bible-passage/<app-bible-passage/;
        }
      }
      if ($stage == 1) {
        if ($line =~ /<\/app-bible-passage/) {
          $line =~ s/<\/app-bible-passage.*/<\/app-bible-passage>/;
          $nextstage=0;
        }
      }
      if ($stage == 1) {
        print XHTML $line;
        $stage=$nextstage;
      }
    }
    print XHTML "</body></html>";
    close HTML;
    close XHTML;
  }

  if ( ! -f $xxml ) {
    my $dom = XML::LibXML->load_xml(location => "$xhtml" );
    my @dvoi=();
    my %dvoi=();
    foreach my $passage ($dom->findnodes('//app-bible-passage')) {
      my @attrs=$passage->attributes();
      foreach my $attr (@attrs) {
        next if ( $attr !~ /^ *data-chapter-string/ );
        my $v=$attr; $v=~ s/.*="//g; $v=~ s/"//g;
      }
      my $exp_ix=0;
      foreach my $span ($passage->findnodes('//span')) {
        my @attrs=$span->attributes();
        foreach my $attr (@attrs) {
          next if ( $attr !~ /^ *data-verse-org-id/ );

          my $v=$attr; $v=~ s/.*="//g; $v=~ s/"//g;
          if ( ! $dvoi{$v} ) {
            $exp_ix++;
            my $vv=$v;
            $vv=~ s/.*\.//;
            if ( $exp_ix != $vv ) {
                print "OEPS: $vv while expecting $exp_ix ($attr)\n" ;
                while ( $exp_ix != $vv ) {
                  print "  insert dummy $exp_ix\n" ;
                  my $xv=$v;
                  $xv=~ s/[^\.]*$//;
                  $xv.=$exp_ix;
                  push @dvoi,$xv;
                  my @o=();
                  $dvoi{$xv}=\@o;
                  $exp_ix++;
                }
            }
            push @dvoi,$v;
            my @o=();
            $dvoi{$v}=\@o;
          }
          my $p=$dvoi{$v};
          push @$p, $span->to_literal(); 
        }
      }
    }
    if ( ! open( XML, ">:encoding(UTF-8)","$xxml" ) ){  error "cannot open $xxml"; return 1; }
    print XML "   <CHAPTER cnumber=\"$chap\">\n" ;
    for my $v (@dvoi) {
      my $p = $dvoi{$v};
      $v=~ s/.*\.//;
      print XML "    <VERS vnumber=\"$v\">";
      my $sep="";
      for my $l (@$p) {
        print XML "$sep$l";
        $sep=" ";
      }
      print XML "</VERS>\n";
    }
    print XML "   </CHAPTER>\n" ;
    close XML;
  }
  return 0;
}

sub doexit($) {
  exit(1);
}

sub zefMain {
  while ( $ARGV[0] ) {
      my $cmd= $ARGV[0]; 
      shift @ARGV;
      if ( $cmd eq "help" ) { return cmd_help( @ARGV ); 
      } elsif ( $cmd eq "nbg" ) { return cmd_nbg( @ARGV ); 
      } else { error("unknown command '$cmd'"); return(1); 
      }
  }
  return 0;
}
while ( $ARGV[0] =~ /^-/ ) {
  if ( common_option( $ARGV[0] ) == 0 ) {
      shift @ARGV;
      next;
  }
  error("unknown common option: $ARGV[0]");
  usage();
  exit 1;
}
doinit();
verbose("zefMain ". join( " ", @ARGV ));
doexit( zefMain(@ARGV) );

